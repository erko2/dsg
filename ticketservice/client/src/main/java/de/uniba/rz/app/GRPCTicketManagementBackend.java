package de.uniba.rz.app;

import de.uniba.rz.converter.TicketTransferConverter;
import de.uniba.rz.entities.Priority;
import de.uniba.rz.entities.Ticket;
import de.uniba.rz.entities.TicketException;
import de.uniba.rz.entities.Type;
import de.uniba.rz.io.rpc.*;
import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;

import java.util.*;

public class GRPCTicketManagementBackend implements TicketManagementBackend {

    HashMap<Integer, Ticket> localTicketStore = new HashMap<>();

    private final ManagedChannel channel;
    private final TicketManagementServiceGrpc.TicketManagementServiceBlockingStub syncStub;

    private AutoUpdate autoUpdate;

    GRPCTicketManagementBackend() {
        this.channel = ManagedChannelBuilder.forAddress("localhost", 8999).usePlaintext().build();

        // stubs are generated by the "protoc" tool (in our case during the gradle build)
        this.syncStub = TicketManagementServiceGrpc.newBlockingStub(this.channel);
    }

    // Set AutoUpdate (for broadcasting)
    public void setAutoUpdate(AutoUpdate autoUpdate) {
        this.autoUpdate = autoUpdate;
            autoUpdate.startAutoUpdating();
    }

    /**
     * Synchronous communication using the corresponding stub. The builder methods are part of the generated class
     * files
     */
    @Override
    public Ticket createNewTicket(String reporter, String topic, String description, Type type, Priority priority) {
        CreateTicketTransferObject createTicketTransferObject = CreateTicketTransferObject.newBuilder()
                .setReporter(reporter)
                .setTopic(topic)
                .setDescription(description)
                .setType(Enum.valueOf(de.uniba.rz.io.rpc.Type.class, type.toString()))
                .setPriority(Enum.valueOf(de.uniba.rz.io.rpc.Priority.class, priority.toString()))
                .build();
        TicketTransferObject response = syncStub.createNewTicket(createTicketTransferObject);
        Ticket ticket = TicketTransferConverter.convertToTicket(response);
        System.out.println(ticket);
        localTicketStore.put(ticket.getId(), ticket);

        return ticket;
    }

    @Override
    public List<Ticket> getAllTickets() throws TicketException {
        List<Ticket> ticketList = new LinkedList<>();
        TicketRequest ticketRequest = TicketRequest.newBuilder().build();
        Iterator<TicketTransferObject> allTickets = syncStub.getAllTickets(ticketRequest);

        while (allTickets.hasNext()){
            ticketList.add(TicketTransferConverter.convertToTicket(allTickets.next()));
        }
        for (Ticket ticket : ticketList){
            localTicketStore.put(ticket.getId(), ticket);
        }

        return ticketList;
    }

    @Override
    public Ticket getTicketById(int id) throws TicketException {
        if (!localTicketStore.containsKey(id)) {
            throw new TicketException("Ticket ID is unknown");
        }
        return (Ticket) getTicketByIdInteral(id).clone();
    }

    private Ticket getTicketByIdInteral(int id) throws TicketException {
        if (!localTicketStore.containsKey(id)) {
            throw new TicketException("Ticket ID is unknown");
        }
        return localTicketStore.get(id);
    }

    @Override
    public Ticket acceptTicket(int id) {
        System.out.println("CLIENT ID of Ticket to ACCEPT: " + id);
        TicketId ticketId = TicketId.newBuilder().setId(id).build();
        TicketTransferObject response = syncStub.acceptTicket(ticketId);
        Ticket updatedTicket = TicketTransferConverter.convertToTicket(response);
        localTicketStore.put(updatedTicket.getId(), updatedTicket);
        return updatedTicket;
    }

    @Override
    public Ticket rejectTicket(int id) {
        System.out.println("CLIENT ID of Ticket to REJECT: " + id);
        TicketId ticketId = TicketId.newBuilder().setId(id).build();
        TicketTransferObject response = syncStub.rejectTicket(ticketId);
        Ticket updatedTicket = TicketTransferConverter.convertToTicket(response);
        localTicketStore.put(updatedTicket.getId(), updatedTicket);
        return updatedTicket;
    }

    @Override
    public Ticket closeTicket(int id) {
        System.out.println("CLIENT ID of Ticket to CLOSE: " + id);
        TicketId ticketId = TicketId.newBuilder().setId(id).build();
        TicketTransferObject response = syncStub.closeTicket(ticketId);
        Ticket updatedTicket = TicketTransferConverter.convertToTicket(response);
        localTicketStore.put(updatedTicket.getId(), updatedTicket);
        return updatedTicket;
    }

    @Override
    public void triggerShutdown() {
        // TODO: deregister from automated updating
        autoUpdate.getRequestObserver().onCompleted();
    }

}
